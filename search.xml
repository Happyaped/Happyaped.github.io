<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>算法概念</title>
      <link href="/2024/09/09/%E7%AE%97%E6%B3%95%E6%A6%82%E5%BF%B5/"/>
      <url>/2024/09/09/%E7%AE%97%E6%B3%95%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="算法概念"><a href="#算法概念" class="headerlink" title="算法概念"></a>算法概念</h1><h2 id="Big-Oh"><a href="#Big-Oh" class="headerlink" title="Big-Oh"></a>Big-Oh</h2><p><img src="/pictures/AlgorithmConcept(1).png" alt="alt text"></p><p>计算比较简单，计算方法是放缩进行放大</p><p><img src="/pictures/AlgorithmConcept(2).png" alt="alt text"></p><h2 id="Big-Omega"><a href="#Big-Omega" class="headerlink" title="Big-Omega"></a>Big-Omega</h2><p><img src="/pictures/AlgorithmConcept(3).png" alt="alt text"></p><p>计算方法是放缩进行放小</p><p>同样的调和级数的例子：</p><p><img src="/pictures/AlgorithmConcept(4).png" alt="alt text"></p><h2 id="Big-Theta"><a href="#Big-Theta" class="headerlink" title="Big-Theta"></a>Big-Theta</h2><p><img src="/pictures/AlgorithmConcept(5).png" alt="alt text"></p><p>也就是说Big-Theta是取决于Big-Omega和Big-Oh的结果，因为这两个分别是放大和放小，所以感觉Big-Theta体现的是一种夹逼思想，而Big-Oh和Big-Omega分别负责上下界的确定</p><h2 id="对数的量级"><a href="#对数的量级" class="headerlink" title="对数的量级"></a>对数的量级</h2><p><img src="/pictures/AlgorithmConcept(6).png" alt="alt text"></p><p>换底公式解决，这说明了对数的量级问题</p><h2 id="递归树法"><a href="#递归树法" class="headerlink" title="递归树法"></a>递归树法</h2><p><img src="/pictures/AlgorithmConcept(7).png" alt="alt text"></p><p>体现为所有结点的和为我们所求的${T(n)}$</p><p>量级体现，主要就是等比数列和直接放缩：<br><img src="/pictures/AlgorithmConcept(8).png" alt="alt text"></p><h2 id="代入法"><a href="#代入法" class="headerlink" title="代入法"></a>代入法</h2><p><img src="/pictures/AlgorithmConcept(9).png" alt="alt text"></p><h2 id="主方法"><a href="#主方法" class="headerlink" title="主方法"></a>主方法</h2><p><img src="/pictures/AlgorithmConcept(10).png" alt="alt text"><br>d与$log_b{a}$谁大听谁的，一样大多乘一个 $log_2{n}$。</p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译原理基本概念</title>
      <link href="/2024/09/06/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E5%BF%B5/"/>
      <url>/2024/09/06/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>一般是将高级语言(e.g. C，Java···)转换为汇编语言(指令集)的过程</p><h2 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h2><p>将汇编语言转换为机器语言(二进制码)的过程</p><h2 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h2><p>编译过程包含了词法分析，语法分析，语义分析生成中间代码，代码优化和生成目标程序五个阶段</p><h3 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h3><p>将源程序字符串根据该种语言的词法规定识别单词并以编码形式输出</p><h3 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h3><p>根据语法规则，分析并识别出各种语法成分(递归下降)</p><h3 id="语义分析生产中间代码"><a href="#语义分析生产中间代码" class="headerlink" title="语义分析生产中间代码"></a>语义分析生产中间代码</h3><p>对识别出的各种语法成分进行语义分析并产生中间代码，中间代码是一种介于源语言和目标程序的中间形式，中间代码好处是便于优化处理和 编译程序的移植</p><p>中间代码的形式包含了四元式，三元式，逆波兰表示等<br>代码优化是为了得到高质量的目标程序</p><h3 id="符号表管理"><a href="#符号表管理" class="headerlink" title="符号表管理"></a>符号表管理</h3><p>在编译过程中需要进行见表并及时记录源程序信息和编译过程中产生的信息</p><h3 id="出错处理"><a href="#出错处理" class="headerlink" title="出错处理"></a>出错处理</h3><p>源程序可能存在错误，编译器需要报告出错误的种类和位置方便用户修改</p><h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><p>和源程序有关的部分，包含了词法语法分析，语义分析，中间代码生成，代码优化</p><h3 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h3><p>和目标机有关的部分，包含了目标程序生成</p><h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p><img src="/pictures/CompileProcess.png" alt="alt text"></p>]]></content>
      
      
      <categories>
          
          <category> Compile </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法开课前的知识回顾</title>
      <link href="/2024/09/02/%E7%AE%97%E6%B3%95%E5%9B%9E%E9%A1%BE/"/>
      <url>/2024/09/02/%E7%AE%97%E6%B3%95%E5%9B%9E%E9%A1%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="知识回顾"><a href="#知识回顾" class="headerlink" title="知识回顾"></a>知识回顾</h1><h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><h3 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h3><p>对于顺序表而言，顺序查找是遍历查找，时间复杂度是O(n)</p><h3 id="折半查找"><a href="#折半查找" class="headerlink" title="折半查找"></a>折半查找</h3><p>折半查找首先需要有序数据集，方法是把查找对象和数据集中间的元素对比，对象大的话在右边找，小的话在左边找，时间复杂度是O(log2 n)</p><h3 id="插入和删除"><a href="#插入和删除" class="headerlink" title="插入和删除"></a>插入和删除</h3><p>在长度为n的表中第i个位置插入(删除)一个数时间复杂度是O(n),设计移位操作</p><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="创建和求链表长度"><a href="#创建和求链表长度" class="headerlink" title="创建和求链表长度"></a>创建和求链表长度</h3><p>时间复杂度都是O(n)</p><h3 id="头结点前插和某结点后插新节点"><a href="#头结点前插和某结点后插新节点" class="headerlink" title="头结点前插和某结点后插新节点"></a>头结点前插和某结点后插新节点</h3><p>时间复杂度都是O(1)</p><h2 id="栈和队"><a href="#栈和队" class="headerlink" title="栈和队"></a>栈和队</h2><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>后进先出，只允许在一端进行操作，这端叫栈顶LIFO(Last In First Out)</p><h3 id="队"><a href="#队" class="headerlink" title="队"></a>队</h3><p>允许在一端进行插入操作，而在另一端进行删除操作FIFO(First In First Out)</p><h2 id="树和二叉树"><a href="#树和二叉树" class="headerlink" title="树和二叉树"></a>树和二叉树</h2><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>每个结点的度小于等于2，区别左子树和右子树</p><h3 id="完全二叉树和满二叉树"><a href="#完全二叉树和满二叉树" class="headerlink" title="完全二叉树和满二叉树"></a>完全二叉树和满二叉树</h3><p><img src="/pictures/AlgorithmReview(10).png" alt="alt text"></p><h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><h3 id="前中后序遍历"><a href="#前中后序遍历" class="headerlink" title="前中后序遍历"></a>前中后序遍历</h3><p>指的是按照一定顺序对二叉树中每一个结点访问一次，包含了前序，中序，后序遍历，层次遍历，本质是深度优先遍历(DFS)</p><h3 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h3><p>从上到下，从左到右，时间复杂度是O(n)，本质是广度优先算法(BFS)</p><h3 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h3><p><img src="/pictures/AlgorithmReview(11).png" alt="alt text"><br><img src="/pictures/AlgorithmReview(1).png" alt="alt text"></p><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>包含了大顶堆和小顶堆，定义如下<br><img src="/pictures/AlgorithmReview(2).png" alt="alt text"></p><h3 id="Huffman树"><a href="#Huffman树" class="headerlink" title="Huffman树"></a>Huffman树</h3><p>和带权路径有关，定义如下<br><img src="/pictures/AlgorithmReview(3).png" alt="alt text"></p><h3 id="Huffman编码"><a href="#Huffman编码" class="headerlink" title="Huffman编码"></a>Huffman编码</h3><p><img src="/pictures/AlgorithmReview(4).png" alt="alt text"></p><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>方法是遍历之后前插到前面已经排好序的队列之中，时间复杂度最佳情况是O(n),最差情况是O(n^2)，平均情况是O(n^2)</p><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>遍历找最小的排在前面，时间复杂度是O(n^2)</p><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>遍历比较然后大小交换，每一次总能保证最大的排在最后，时间复杂度是O(n^2)</p><h3 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h3><p><img src="/pictures/AlgorithmReview(5).png" alt="alt text"><br>时间复杂度平均情况是O(n*log2 n)</p><h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><h3 id="生成树"><a href="#生成树" class="headerlink" title="生成树"></a>生成树</h3><p><img src="/pictures/AlgorithmReview(6).png" alt="alt text"></p><h3 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h3><h3 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h3><p>名为DFS，从图中某个指定的顶点v出发,先访问顶点v,然后从顶点v未被访问过的一个邻接点出发，继续进行深度优先遍历,直到图中与v相通的所有顶点都被访问，可用于独立路径计算<br><img src="/pictures/AlgorithmReview(7).png" alt="alt text"></p><h3 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h3><p>名为BFS，从图中某个指定的顶点v出发,先访问顶点v,然后依次访问顶点v的各个未被访问过的邻接点,然后又从这些邻接点出发, 按照同样的规则访问它们的那些未被访问过的邻接点，如此下去，直到图中与v 相通的所有顶点都被访问，可用于独立路径计算<br><img src="/pictures/AlgorithmReview(8).png" alt="alt text"></p><h3 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h3><p><img src="/pictures/AlgorithmReview(9).png" alt="alt text"><br>包含了Prim(普利姆)算法,Kruskal(克鲁斯卡尔)算法，这两算法都是贪心算法</p><h3 id="Prim"><a href="#Prim" class="headerlink" title="Prim"></a>Prim</h3><p>从一个顶点出发，找当下的没法构成回路的最小边，直到所有点都被加入树中</p><h3 id="Kruskal"><a href="#Kruskal" class="headerlink" title="Kruskal"></a>Kruskal</h3><p>这个是从整个图的角度出发，找当下的最小边，如果形成回路则放弃</p><h3 id="最短路径问题"><a href="#最短路径问题" class="headerlink" title="最短路径问题"></a>最短路径问题</h3><p>Dijkstra(迪杰斯特拉)算法解决，从一个点出发可以找到这个点和其余所有点的最短路径</p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大二下学期总结</title>
      <link href="/2024/07/08/%E5%A4%A7%E4%BA%8C%E4%B8%8B%E6%80%BB%E7%BB%93/"/>
      <url>/2024/07/08/%E5%A4%A7%E4%BA%8C%E4%B8%8B%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="大二下总结"><a href="#大二下总结" class="headerlink" title="大二下总结"></a>大二下总结</h1><h2 id="一、学习方面"><a href="#一、学习方面" class="headerlink" title="一、学习方面"></a>一、学习方面</h2><p>对于学习方面，我觉得我在这学期最大的问题是上课的时候基本没有听而选择了自学，虽然说自学在大学是一项极其重要的技能，但是上课不听讲纯自学这种模式经过我这学期实践后发现并不适合我，因为我并没有对这些课程有过提前的了解，所以说我觉得一定是要上课认真听老师讲课然后再去课下自学，对于某些老师的课上课如果听不明白，应该先静下心来不要焦虑，放轻松再去听讲，如果实在是听不懂，那么可以问问学长有没有什么好的b站课程，这学期的OS就是活生生的例子，所以一定要强调上课听讲的重要性。</p><p>第二个是学习心态方面，首先我觉得相比于上学期我的心态上就有了很大的进步，像是某次实验挂了就难过的睡不着觉这种情况已经减轻很多了，学习的过程中应当是感受知识的乐趣和一步一步完成项目的过程中有的成就感，而不是纠结于某一次实验的分数又不满意了，从而无休止的精神内耗折磨自己，从容的面对，如果做的不够好就去查漏补缺而不是精神内耗，这些当下我觉得很难或者是给了我很大打击的考试，我相信如同高考一样在未来将会是一件微不足道的小事，将目光放得长远一些，我的收获将会更大，也会更容易陷入正向反馈的循环之中。</p><p>在学习心态方面，还有一个点就是陷入正向反馈而不是负反馈循环，首先只盯着成绩看的话毫无疑问会陷入负反馈循环，因为某一次的失败而闷闷不乐是不应该的，我觉得可以通过感受和鼓励自己完成了一项一项的小任务而得到正向反馈。不要老是和其他人比较觉得自己应该更快更轻松地完成某项任务，在完成任务的过程中的收获是更加重要的，所以在完成任务的过程中，完成了某项小的任务之后需要鼓励自己，可以让自己陷入正向循环面临接下来的挑战而不是抱怨真难，工程量真大。时常的鼓励自己会让自己更有动力来学习。</p><p>第三就是这学期的一个惨痛教训就是没有重视平常的作业完成，比如说看起来没什么用的航概，我经常是20分钟抄完同学的答案就去玩了，关键是抄的还比较水，离散也是平常没怎么学期末突击的，所以说有些课程虽然是水课但是还是要认真完成作业，这种分丢了就太不应该了。虽然之后看起来思政课和水课都上完了讲这些也没啥用。</p><p>最重要的一个还是我觉得在自习的时候不太能够静下心来，经常还是学习一会儿就玩一会儿，我觉得万事开头难，拖延症加上纯结果导向导致了内耗大于了行动，所以说我认为改掉拖延症首先需要改变观念，更加看重成长而非结果和排名，第二，采取行动一定是大于看结果的，我在做任何事情开始的时候不能保证又努力就有好的结果，这样想就会根本不想行动，万事开头难这句话也包含了因为不确定能否有满意的结果而不敢行动，这学期里面写OO我也认为是有了大致框架就先行动了，很多的问题不是一开始就能想明白的，而是船到桥头自然直动手行动才能够明白。所以有了想法和必要的条件之后就先开始行动，行动过程中也能够产生正反馈来支撑你作为继续挑战的动力。采取行动，感受行动中的成长也是抵抗焦虑和内耗的好方法。</p><p>还有就是学习的地点，这学期我主要的学习地点还是寝室和空教室，我觉得如果从客观上来说学一会儿摸一会儿鱼的原因就是缺乏一个氛围，所以下学期还是都去图书馆里面学习吧</p><h2 id="二、生活方面"><a href="#二、生活方面" class="headerlink" title="二、生活方面"></a>二、生活方面</h2><p>在生活方面，我觉得最大的问题还是不太规律，比如说睡得还是太晚，起床之后不吃早饭搞得早上效率不高，应当指定一个规律的作息养成一个生物钟，比如说早上8：00中一定起床，晚上12：00一定睡觉，早上起来一定去吃早饭等等。</p><p>第二个是休闲放松的方式，这学期基本上休闲放松的方式还是以游戏为主，我原来是很反感用运动的方式来休闲放松，直到这学期因为游泳考核第一次早上8：00起床去游泳，这绝对是我游过的最爽的一次，我觉得可以沿用到大三整个学期，周末的两天早上可以去游泳来放松自己而不是选择打游戏，打游戏感觉更像是逃避压力而不是释放压力，我想在秋冬季节游泳也肯定是神清气爽。</p><h2 id="三、人际交往方面"><a href="#三、人际交往方面" class="headerlink" title="三、人际交往方面"></a>三、人际交往方面</h2><p>这学期还是通过足球认识了很多新的朋友，自己也组织了一场足球比赛，同时也担任了冯如杯项目的队长来完成了一项冯如杯项目，虽然我也看不懂完成的到底是个啥（笑），但总归是锻炼了自己这方面的能力，从原来的社恐到现在也能够组织一些活动，我觉得这方面也有所进步吧，再接再厉。</p><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>这学期在学习方面心态有进步，但是还是有一些错误的观念，在学习的心态和策略方面有很多地方还可以进步，对于内耗的心理，用行动是最好的良药，敢想敢做，在生活方面应当去尝试放松方式的改变，下学期开始游泳活动，人际交往方面有所进步，再接再厉，加油！</p>]]></content>
      
      
      <categories>
          
          <category> Review </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学期总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OO第四单元总结</title>
      <link href="/2024/07/06/OO-Unit4/"/>
      <url>/2024/07/06/OO-Unit4/</url>
      
        <content type="html"><![CDATA[<h1 id="OO-Unit4-Summary"><a href="#OO-Unit4-Summary" class="headerlink" title="OO Unit4 Summary"></a>OO Unit4 Summary</h1><h2 id="一、写在前面"><a href="#一、写在前面" class="headerlink" title="一、写在前面"></a>一、写在前面</h2><p>在本单元中我们实现了一个图书馆模拟系统，包含了借书，预定，查询，还书等等的功能，本单元的核心在于预先的架构设计，提前做好架构设计并且画好uml图根据uml图写出代码，总而言之是设计思维的训练。</p><h2 id="二、任务要求"><a href="#二、任务要求" class="headerlink" title="二、任务要求"></a>二、任务要求</h2><h3 id="第一次作业"><a href="#第一次作业" class="headerlink" title="第一次作业"></a>第一次作业</h3><p>我个人认为第一次作业最重要，第一次作业的关键在于给出的官方包已经很齐全了，不要重复造轮子，在第一次作业第一遍写的时候由于写了book和bookshelf两层而导致查询异常麻烦，仔细读了官方包后发现这两层完全不需要，也给扩展留出了很多的空间。</p><h3 id="第二次作业"><a href="#第二次作业" class="headerlink" title="第二次作业"></a>第二次作业</h3><p>第二次作业只需要在第一次的基础上加一个图书漂流角然后修改下整理图书的过程，完成的较快，当然这也肯定是助教考虑到了我们有航概考试，感谢助教不杀之恩。</p><h3 id="第三次作业"><a href="#第三次作业" class="headerlink" title="第三次作业"></a>第三次作业</h3><p>第三次作业也比较简单，没有新加的类，主要的改动在于引入了信用分机制，主要修改了预约，整理图书这两个部分，其他部分根据了信用分规则小改。</p><h2 id="三、正向建模与开发"><a href="#三、正向建模与开发" class="headerlink" title="三、正向建模与开发"></a>三、正向建模与开发</h2><p>我所理解的正向建模与开发是基于系统的目标和他的行为，还有这个系统的各个部分之间的关系来构建模型。我认为正向建模是一个从整体细化的过程，同时描述了系统的结构和功能以及各个部件他们之间的关系。</p><p>在本单元中，我是先有一个ParserInput类负责解析了输入之后将需要的信息传给了作为中心的Library类，Library类负责和各个类进行交互并且拿到结果最终输出，剩下的则是各个部分，Corner代表了漂流角，BorrowPlace代表了借还处，OrderPlace代表了预约处，Student代表了学生，而Request代表了预约的请求。</p><h2 id="四、架构设计"><a href="#四、架构设计" class="headerlink" title="四、架构设计"></a>四、架构设计</h2><h3 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h3><p>最终架构设计如下<br><img src="/pictures/OO_4(1).png" alt="alt text"><br>如同上文</p><p>先是ParserInput类解析输入并且把有用的信息传给了Library，Library作为核心和其他的部分进行交互拿到信息并且输出了最终的结果，这个架构就是各个部分各司其职，然后Library作为中心来交互。</p><p>其中Corner是图书漂流处，包含了一个书架和hashmap来记录捐献者，BorrowPlace是借还处，有一个书架和一个hashmap来记录借还次数，OrderPlace是预约处，有两个Arraylist来记录在预约处的书和将要在下一次整理时放到预约处的书，然后是Student代表了学生，每个学生也有一个自己的书架。</p><p>状态转移图如下<br><img src="/pictures/OO_4(2).png" alt="alt text"></p><p>顺序图如下：<br><img src="/pictures/OO_4(3).png" alt="alt text"></p><h3 id="代码和UML模型的追踪关系"><a href="#代码和UML模型的追踪关系" class="headerlink" title="代码和UML模型的追踪关系"></a>代码和UML模型的追踪关系</h3><p>我认为代码和UML模型之间的追踪关系是指的是代码和架构图中类元素，变量元素，方法元素的一致性</p><h4 id="1-工具支持"><a href="#1-工具支持" class="headerlink" title="1.工具支持"></a>1.工具支持</h4><p>IDEA和UML提供了工具支持了代码和UML模型之间的追踪</p><h4 id="2-命名规范"><a href="#2-命名规范" class="headerlink" title="2.命名规范"></a>2.命名规范</h4><p>我们可以通过规范统一的命名来快速检查代码和UML模型之间的追踪关系</p><h4 id="3-注释"><a href="#3-注释" class="headerlink" title="3.注释"></a>3.注释</h4><p>我们可以通过在代码中写注释来注明代码和UML之间的追踪关系</p><h2 id="五、四个单元中架构思维的演进"><a href="#五、四个单元中架构思维的演进" class="headerlink" title="五、四个单元中架构思维的演进"></a>五、四个单元中架构思维的演进</h2><p>在这四个单元中，随着对于面向对象思维的了解逐渐加深，我认为我的架构也在变得更加清晰。从第一个单元来说，我的架构是表达式，因子，以及项都是兼顾了递归下降的功能和计算结果的功能，也就是说压根不符合高内聚低耦合的设计思想，而是把功能都融合成了一块儿，非常混乱。在第二个单元中我认为我的架构使用了多种的模式，比如生产者消费者模式，以及工厂模式，提高了我的架构的扩展性以及让我的架构更加清晰明了，第三个单元是按照JML写没有怎么设计架构，而第四个单元中我认为我的架构可以说是各司其职，每个部分都是有着明确的功能，也是符合了高内聚低耦合的思想。所以说我认为架构思维演进包括了高内聚低耦合思维上的认识，面向对象的认识加深，工厂模式，生产者消费者模式等的应用等等。</p><h2 id="六、四个单元中测试思维的演进"><a href="#六、四个单元中测试思维的演进" class="headerlink" title="六、四个单元中测试思维的演进"></a>六、四个单元中测试思维的演进</h2><p>在这四个单元的测试中我认为JUnit测试给了我对于测试认知比较大的改变，需要得到的目标，以及需要保障那些变量不能变化，测试数据的全面性，以及测试数据的边缘性，都能在JUnit测试中体现。</p><p>对于四个单元测试中思维的演进，从第一个单元几乎只靠弱测和中测导致我强测g的很惨，到第二个单元课下充分测试达成了第一单元总结中立下的目标，到第三个单元通过JUnit对于各种测试有更加深刻的认识，到第四个单元没出bug完成三次作为。我认为我对于测试的认识也在不断地提高。</p><h2 id="七、课程收获"><a href="#七、课程收获" class="headerlink" title="七、课程收获"></a>七、课程收获</h2><p>我觉得对于我而言最大的收获是抗压能力上的收获，各种实际的收获已经在每个单元的博客中总结过了，第一单元和第二单元对于我的抗压能力可以说是有着极大的考验，尤其是第一个单元，还沉浸在假期的美好回忆之中，突然狠狠上强度，红温是第一个单元的常态，而经历了前两个单元的洗礼，我认为我的心态和抗压能力都得到了提升，我原来是认为应该把每个细节都想明白再动手写而导致了犹豫不决，我从第三个单元开始则是有个大概的结构就开始动手写，很多事情是写到了那个时候就自然明白了，光靠想是想不明白的，所谓的“船到桥头自然直”。而对于抗压能力上而言，从周一周二的迷茫，到周三上机之后有思路，到周五完成后开始debug，开始测试，到互测时想尽办法刀别人，再到周一晚上看强测结果修复bug又开始了新的一周，OO课程极大的锻炼了我的抗压能力，我觉得这是比其他的收获更加宝贵的，感谢OO！</p>]]></content>
      
      
      <categories>
          
          <category> Object Oriented </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OO第三单元总结</title>
      <link href="/2024/07/06/OO-Unit3/"/>
      <url>/2024/07/06/OO-Unit3/</url>
      
        <content type="html"><![CDATA[<h1 id="OO第三单元总结"><a href="#OO第三单元总结" class="headerlink" title="OO第三单元总结"></a>OO第三单元总结</h1><h2 id="一、写在前面"><a href="#一、写在前面" class="headerlink" title="一、写在前面"></a>一、写在前面</h2><pre><code>  第三单元我们完成了一个模拟社交关系查询系统，其中包含了人，关系，标签，信息等。学习了JML规格理解和代码实现，以及容器的选择和算法的优化。JML作为一种要求和规则给出了我们要实现的功能，在以后或许我们会遇到其他规格语言或者自然语言来作为规格，但是规范开发和便于测试的思想会存于我们的开发过程。同时，在读懂了JML后选择实现的方式也是至关重要的。</code></pre><h2 id="二、架构与模型构建"><a href="#二、架构与模型构建" class="headerlink" title="二、架构与模型构建"></a>二、架构与模型构建</h2><h3 id="2-1-UML框架图"><a href="#2-1-UML框架图" class="headerlink" title="2.1 UML框架图"></a>2.1 UML框架图</h3><p><img src="/pictures/OO_3(3).png" alt="alt text"> </p><h3 id="2-2-架构设计"><a href="#2-2-架构设计" class="headerlink" title="2.2 架构设计"></a>2.2 架构设计</h3><h4 id="MyPerson"><a href="#MyPerson" class="headerlink" title="MyPerson"></a>MyPerson</h4><p><img src="/pictures/OO_3(4).png" alt="alt text"><br>  MyPerson类仅仅按照JML的要求来构造了相应的属性，对于acquaintance和value以及tags这三个属性由于person的id和tag的id各自不会有重复的，所以选择了Hashmap来作为容器。</p><h4 id="MyTag"><a href="#MyTag" class="headerlink" title="MyTag"></a>MyTag</h4><p><img src="/pictures/OO_3(5).png" alt="alt text"><br>  MyTag中除了JML中要求的之外我还有个sum用于维护ValueSum，在MyNetwork中的queryValueSum这个方法的查询复杂度是N（2），如果不维护的话肯定会tle。</p><h4 id="MyMessage"><a href="#MyMessage" class="headerlink" title="MyMessage"></a>MyMessage</h4><p><img src="/pictures/OO_3(6).png" alt="alt text"><br>MyMessage仅仅按照JML填写，没有额外维护。</p><h4 id="MyNetwork"><a href="#MyNetwork" class="headerlink" title="MyNetwork"></a>MyNetwork</h4><p><img src="/pictures/OO_3(7).png" alt="alt text"><br>可以看到MyNetwork中的容器基本上选择的是HashMap，封装了对维护类的处理和迪杰斯特拉，其中迪杰斯特拉用于查询最短路径，blockSum和triSum动态维护了关系网中块儿的数量和三角形的数量，而isDirty则是标志了维护的IdMap是否因为被修改了关系而作废了，除此之外都是JML的要求。</p><h4 id="异常类（以RelationNotFound为例）"><a href="#异常类（以RelationNotFound为例）" class="headerlink" title="异常类（以RelationNotFound为例）"></a>异常类（以RelationNotFound为例）</h4><p><img src="/pictures/OO_3(1).png" alt="alt text"><br>可以看到采用了static的变量，并且counter类用于计数，counter类包含了一个总的计数器以及一个Hashmap来存储id对应的数量。<br><img src="/pictures/OO_3(2).png" alt="alt text"></p><h2 id="三、维护策略"><a href="#三、维护策略" class="headerlink" title="三、维护策略"></a>三、维护策略</h2><p>本单元中我对于查询方法中复杂度大于等于N(2)的方法进行了动态维护，在hw9中是对于queryBlockSum以及queryTripleSum两个方法进行了动态维护，方法是通过在加人，加关系和删关系的时候去相应的维护，其中blockSum的维护需要去查看并查集。</p><p>在hw10中我对于queryTagValueSum方法进行了维护是通过在MyTag中增加了sum属性，在MyTag中加人删人以及MyNetwork中加关系以及删关系中进行了维护。</p><h2 id="四、测试理解"><a href="#四、测试理解" class="headerlink" title="四、测试理解"></a>四、测试理解</h2><h3 id="4-1-黑箱测试"><a href="#4-1-黑箱测试" class="headerlink" title="4.1 黑箱测试"></a>4.1 黑箱测试</h3><p>黑盒测试，它是通过测试来检测每个功能是否都能正常使用。它只检查程序功能是否按照需求规格说明书的规定正常使用，程序是否能适当地接收输入数据而产生正确的输出信息。黑盒测试着眼于程序外部结构，不考虑内部逻辑结构，主要针对软件界面和软件功能进行测试。在Unit3中体现在部分中测点以及JUnit测试之中。</p><h3 id="4-2-白箱测试"><a href="#4-2-白箱测试" class="headerlink" title="4.2 白箱测试"></a>4.2 白箱测试</h3><p>白箱测试则是在考虑软件内部实现的情况下，对软件进行测试的方法。在白箱测试中，测试人员需要了解软件的内部结构、代码逻辑等，以便能够对软件进行有效的测试。白箱测试通常用于测试软件的可靠性、安全性等方面。体现在强测以及部分中测点。</p><h3 id="4-3-单元测试"><a href="#4-3-单元测试" class="headerlink" title="4.3 单元测试"></a>4.3 单元测试</h3><p>单元测试是指对软件中的最小可测试单元进行检查和验证。对于单元测试中单元的含义，一般来说，要根据实际情况去判定其具体含义，如C语言中单元指一个函数，Java里单元指一个类，图形化的软件中可以指一个窗口或一个菜单等。总的来说，单元就是人为规定的最小的被测功能模块。单元测试是在软件开发过程中要进行的最低级别的测试活动，软件的独立单元将在与程序的其他部分相隔离的情况下进行测试。体现在JUnit中对于单个方法的测试。</p><h3 id="4-4-功能测试"><a href="#4-4-功能测试" class="headerlink" title="4.4 功能测试"></a>4.4 功能测试</h3><p>功能测试就是对产品的各功能进行验证，根据功能测试用例，逐项测试，检查产品是否达到用户要求的功能。</p><h3 id="4-5-集成测试"><a href="#4-5-集成测试" class="headerlink" title="4.5 集成测试"></a>4.5 集成测试</h3><p>在单元测试的基础上，将所有模块按照设计要求组装成为子系统或系统，进行集成测试。体现在JUnit中对于main方法进行测试。</p><h3 id="4-6-压力测试"><a href="#4-6-压力测试" class="headerlink" title="4.6 压力测试"></a>4.6 压力测试</h3><p>是指对软件系统在高并发、大负荷、长时间运行等特殊条件下进行测试，以验证系统的稳定性、可靠性和性能指标等是否能够满足要求。体现在强测以及互测中大量的查询方法。</p><h3 id="4-7-回归测试"><a href="#4-7-回归测试" class="headerlink" title="4.7 回归测试"></a>4.7 回归测试</h3><p>回归测试是指修改了旧代码后，重新进行测试以确认修改没有引入新的错误或导致其他代码产生错误。自动回归测试将大幅降低系统测试、维护升级等阶段的成本。我想是体现在对于hw10中修改了hw9中的modifyRelation方法以及相关的测试。</p><h2 id="五、数据构造的策略"><a href="#五、数据构造的策略" class="headerlink" title="五、数据构造的策略"></a>五、数据构造的策略</h2><p>对于数据构造的话我是选择了以压力测试为主，通过调用大量的JML中的高复杂度方法来看本地运行的时间以及和同学对拍来看是否符合要求</p><h2 id="六、性能问题以及修复情况"><a href="#六、性能问题以及修复情况" class="headerlink" title="六、性能问题以及修复情况"></a>六、性能问题以及修复情况</h2><h3 id="6-1"><a href="#6-1" class="headerlink" title="6.1"></a>6.1</h3><p>在Unit3中，hw9最开始我是仅仅按照JML编写，发现超时后添加了triSum和blockSum来进行维护，用到了并查集和动态维护两个优化，其中并查集里面又用到了路径压缩和按秩合并。测试没有出现性能问题。</p><p>hw10中用到了Dijkstra算法来查找最短路径，其中还用到了脏位来减少查询次数。动态维护了ValueSum。测试出现了大量的qtvs是我会tle，所以加上了动态维护。</p><h3 id="6-2-规格与实现的分离"><a href="#6-2-规格与实现的分离" class="headerlink" title="6.2 规格与实现的分离"></a>6.2 规格与实现的分离</h3><p>我认为规格仅仅是描述了要求，针对于实现而言可以不局限于这个方法，采用动态维护就是规格和实现分离的体现，我们可以在规格的要求上采用算法来优化复杂度，可以动态维护而不是选择多重循环嵌套，所以规格仅仅是描述了要求，具体的实现多种多样。</p><h2 id="七、JUnit和体会"><a href="#七、JUnit和体会" class="headerlink" title="七、JUnit和体会"></a>七、JUnit和体会</h2><p>对于JUnit测试我认为是让我们更好的理解了规格，我们需要考虑这个方法中哪些东西会改变，哪些不会改变，如何去判断，又以什么样的比例去构造测试点来去测试，还有就是我们构造的模拟社交关系的数据点是否过于稠密或是过于稀疏，这些都是要考虑的问题，因此我认为JUnit是加深了我们对于JML的理解的。</p><h2 id="八、Hack策略分析"><a href="#八、Hack策略分析" class="headerlink" title="八、Hack策略分析"></a>八、Hack策略分析</h2><p>在hw9中我选择的策略是压力测试，通过大量的qbs和qcs来测试是否会tle。</p><p>在hw10中我采用的也是压力测试，通过大量的qtvs来测试是否会tle。</p><p>在hw11中则是所有的查询都混合着构造数据。</p><h2 id="九、心得体会"><a href="#九、心得体会" class="headerlink" title="九、心得体会"></a>九、心得体会</h2><p>这个单元总体而言的难度比不上上两个单元，难度主要是在如何优化自己的程序使得不会在强测和互测中挂掉，在这个单元中我学习了很多的算法和优化上的知识，同时也认识到了规格化开发的各种好处，也更加有利于我们开展单元测试，即是以后可能会遇到其他的规格语言，但是其中蕴含的思想是一样的。还剩下最后一个单元了，革命即将成功，加油！！！！</p>]]></content>
      
      
      <categories>
          
          <category> Object Oriented </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OO第二单元总结</title>
      <link href="/2024/07/06/OO-Unit2/"/>
      <url>/2024/07/06/OO-Unit2/</url>
      
        <content type="html"><![CDATA[<h1 id="OO-Unit2单元总结"><a href="#OO-Unit2单元总结" class="headerlink" title="OO Unit2单元总结"></a>OO Unit2单元总结</h1><h2 id="总架构图"><a href="#总架构图" class="headerlink" title="总架构图"></a>总架构图</h2><p><img src="/pictures/OO_2(3).png" alt="alt text"><br>生产者-消费者模式</p><h2 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h2><p><img src="/pictures/OO_2(4).png" alt="alt text"></p><h2 id="同步块的设置和锁的选择"><a href="#同步块的设置和锁的选择" class="headerlink" title="同步块的设置和锁的选择"></a>同步块的设置和锁的选择</h2><h3 id="hw5"><a href="#hw5" class="headerlink" title="hw5"></a>hw5</h3><p>在hw5中，我都是对于方法上锁，对RequestTable类的所有方法都上了锁，RequestTable类是请求的集合，也就是生产者和调度器，调度器和消费者唯一的共享对象类，对于这个类的所有方法上锁可以保障线程安全问题的解决。</p><h3 id="hw6"><a href="#hw6" class="headerlink" title="hw6"></a>hw6</h3><p>在hw6中，我依然保持了hw5中对于RequestTable上的锁，并且对于hw6中增加的一个receiveResetRequest的方法用于把reset的电梯的里面的人和配给他但是没有去接的人放给主请求队列，初次之外，我对Elevator中的一个表示是否在reset状态的变量isReset的get和set方法进行了加锁，这个变量是调度器和电梯共享的变量，都是可读可写所以要加锁。</p><h3 id="hw7"><a href="#hw7" class="headerlink" title="hw7"></a>hw7</h3><p>在hw7中，对于DCReset的加锁方式类比于hw6，对于双轿厢电梯我的处理方法是把当下的电梯变成一个调度器，然后新增A和B轿厢，AB轿厢的实现和加锁也类比于总调度器和普通电梯。</p><p>而对于双轿厢电梯不相撞的要求，我让两个线程共享了一个isInChangeFloor的类对象，对他的方法加锁，并且在AB轿厢的move（）中加锁保障了线程安全来保障双轿厢不会相撞。</p><h2 id="调度器与线程互动"><a href="#调度器与线程互动" class="headerlink" title="调度器与线程互动"></a>调度器与线程互动</h2><p>调度器和线程进行互动的方法是通过共享对象RequestTable，也就是调度器分配给这个电梯线程的任务。通过对于</p><h2 id="调度器设计与调度策略"><a href="#调度器设计与调度策略" class="headerlink" title="调度器设计与调度策略"></a>调度器设计与调度策略</h2><p>在hw5中，由于指定了上的电梯，所以调度器不包含调度算法，他起的作用仅仅是把请求放到对应的和电梯的共享对象里。</p><p>在hw6中，需要我们自己设计调度算法来分配，并且由于增加了重置功能，所以我们不能给正在重置的电梯分配任务，我才用的是均匀调度，也就是i%6来进行分配,在保证了正确性的前提下是90分左右。均匀调度比较好的一点就是不会给一个电梯过多任务。并且如果看到有5个电梯在重置的话调度器线程就会睡1.2s,牺牲了一点性能来换取正确性。</p><p>在hw7中，我依然采用了均匀调度，并且无论是第一种还是第二种重置的电梯我都不会分配请求，也就是对于第二种重置的处理类似于第一种重置。而且由于双轿厢电梯有耗电量优势以及上下可以同时动的优势，我选择双轿厢只有1个任务和没有任务时优先分配给它。保障了正确性的情况下性能分也是90分左右。</p><h2 id="稳定与易变内容"><a href="#稳定与易变内容" class="headerlink" title="稳定与易变内容"></a>稳定与易变内容</h2><p>稳定的内容包含：</p><p>Main方法<br><img src="/pictures/OO_2(5).png" alt="alt text"><br>Strategy：提供电梯建议，也就是LOOK调度算法，基本没变，hw7单独为AB轿厢提供了调度算法，根据LOOK算法简单修改而得。显然比较稳定。</p><p><img src="/pictures/OO_2(7).png" alt="alt text"><br>易变的内容包含：</p><p>InputThread的run里面需要根据jar包接口的变化来微调，整体变化较小。<br><img src="/pictures/OO_2(6).png" alt="alt text"></p><p>Elevator的run：增加一种reset之后需要微调。<br><img src="/pictures/OO_2(8).png" alt="alt text"></p><p>调度器中的run：需要修改调度方法<br><img src="/pictures/OO_2(1).png" alt="alt text"></p><h2 id="bug与debug方法"><a href="#bug与debug方法" class="headerlink" title="bug与debug方法"></a>bug与debug方法</h2><p>hw5：hw5强测没有bug，但是初次写完后发现有CTLE，debug的方法是在可能的轮询的地方输出一下，如果出现了很多次（上千）的该输出，则说明了该地方轮询，解决方法是wait，notify。</p><p>hw6：hw6强测没有bug但是互测有一个bug，就是卡49s导致把所有请求都分配给了一个电梯导致了RTLE，解决方法是调度器遇到了5个电梯都在reset的话就sleep 1.2s，虽然牺牲了一些性能但是保障了正确性。<br><img src="/pictures/OO_2(2).png" alt="alt text"><br>hw7：hw7强测和互测都没有bug。</p><h2 id="心得与体会"><a href="#心得与体会" class="headerlink" title="心得与体会"></a>心得与体会</h2><p>在第二单元中，我们系统学习了多线程，其中重点就是线程安全问题，在hw6和hw7中也对这个问题很头疼，总的来说是看线程对于的共享对象是可读的，还是可写的，亦或是都有，是否有读写的先后顺序，而加锁又包含了对于对象加锁和对于方法加锁，对于对象加锁的话则需要覆盖对于这个对象的查找和修改操作，对于方法加锁是简洁明了的，也是和最近OS中学到的管程呼应了起来，相比于上个单元，这个单元的表现好了很多，也达成了上个单元总结中给自己指定的目标，感觉OO的学习逐渐进入了状态。下个单元给自己定的目标是多多考虑性能的优化。OO长征路已然走完了一半，革命胜利曙光就在前方，加油！</p>]]></content>
      
      
      <categories>
          
          <category> Object Oriented </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OO第一单元总结</title>
      <link href="/2024/07/06/OO-Unit1/"/>
      <url>/2024/07/06/OO-Unit1/</url>
      
        <content type="html"><![CDATA[<h1 id="OO-Unit1：表达式解析和递归下降的应用"><a href="#OO-Unit1：表达式解析和递归下降的应用" class="headerlink" title="OO Unit1：表达式解析和递归下降的应用"></a>OO Unit1：表达式解析和递归下降的应用</h1><h2 id="一、Unit1简述"><a href="#一、Unit1简述" class="headerlink" title="一、Unit1简述"></a>一、Unit1简述</h2><p>在第一单元的任务中，需要我们对于一个给定的复杂表达式进行一定程度的预处理之后进行递归下降表达式解析，之后根据解析出的结果来输出保留必要括号的形式。</p><h2 id="二、三次任务的要求"><a href="#二、三次任务的要求" class="headerlink" title="二、三次任务的要求"></a>二、三次任务的要求</h2><h3 id="第一次作业"><a href="#第一次作业" class="headerlink" title="第一次作业"></a>第一次作业</h3><p>第一次作业包含的因子较少只有三种<br><img src="/pictures/OO_1(5).png" alt="alt text"></p><h3 id="第二次作业"><a href="#第二次作业" class="headerlink" title="第二次作业"></a>第二次作业</h3><p>第二次作业增加了自定义函数和指数函数因子，指数函数的括号里面是因子<br><img src="/pictures/OO_1(6).png" alt="alt text"></p><h3 id="第三次作业"><a href="#第三次作业" class="headerlink" title="第三次作业"></a>第三次作业</h3><p>第三次作业新增了求导和自定义函数的已知的嵌套调用<br><img src="/pictures/OO_1(7).png" alt="alt text"></p><h2 id="三、设计思路"><a href="#三、设计思路" class="headerlink" title="三、设计思路"></a>三、设计思路</h2><p>我的设计思路是先对于输入的字符串进行一定的预处理，预处理之后将字符串传入Parser类进行解析，运用递归下降方法，解析后的结果是一个Expression类变量，之后进行计算（也是去括号的过程），然后会得到计算后的Expression变量，最终还有个printer类负责输出。</p><h3 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h3><p><img src="/pictures/OO_1(8).png" alt="alt text"><br>首先从main类中获得自定义函数的数量，然后接收后将自定义函数放到Function类中。</p><h3 id="Function类"><a href="#Function类" class="headerlink" title="Function类"></a>Function类</h3><p>Function类包含了自变量数量，函数表达式，以及自变量的先后顺序。<br><img src="/pictures/OO_1(13).png" alt="alt text"></p><h3 id="Lexer类"><a href="#Lexer类" class="headerlink" title="Lexer类"></a>Lexer类</h3><p>记录下了自定义函数后我们将记录的自定义函数传入Lexer类，之后对字符串进行预处理，预处理包含了对于空格和水平制表符进行处理，对于连续的+-符号进行处理，把-变成-1*，如果首项是+或-变成0+或者0-，替换自定义函数等等。<br>部分代码如下图所示<br><img src="/pictures/OO_1(14).png" alt="alt text"><br>替换自定义函数</p><p><img src="/pictures/OO_1(15).png" alt="alt text"><br>Lexer类包含了next(),getNumber(),以及peek()等方法，主要从课程组给的第一单元训练代码中copy下来的，用来提供curToken来供Parser进行解析。</p><h3 id="Parser类"><a href="#Parser类" class="headerlink" title="Parser类"></a>Parser类</h3><p>我们将定义的Lexer变量传入Parser类，Parser根据Lexer提供的curToken进行解析，包含表达式解析，项解析以及因子解析，代码和课程组发的第一单元训练代码一个思路。部分代码如下图所示<br><img src="/pictures/OO_1(16).png" alt="alt text"></p><h3 id="Expr文件夹"><a href="#Expr文件夹" class="headerlink" title="Expr文件夹"></a>Expr文件夹</h3><p>Expr文件夹下包含了Expression，Term，Var，Num，Exponent，Derivation等等，因子为Factor接口。</p><p>递归下降解析完后我们得到了一个存储了解析信息的Expression变量，之后我们需要进行计算，因此我们提取出了标准项类Standard</p><h3 id="Standard"><a href="#Standard" class="headerlink" title="Standard"></a>Standard</h3><p>解析完的表达式可以看作是一棵树，每个节点的价值便是标准项的Arraylist，第一次作业可以用Hashmap来计算每个节点的价值，但是之后无法支撑第二次作业要求，因此提取了标准项来表示。部分代码如下<br><img src="/pictures/OO_1(17).png" alt="alt text"></p><h3 id="Expression，Term等类"><a href="#Expression，Term等类" class="headerlink" title="Expression，Term等类"></a>Expression，Term等类</h3><p>Expression，Term等类首先是他们的成员变量，包含了Arraylist Standard和对标给的指导书就行。部分代码如下<br><img src="/pictures/OO_1(18).png" alt="alt text"><br>其中对于指数的处理我们可以在预处理就展开，也可以在计算的时候在处理，这里我选择的是后者因此在表达式类中包含了index作为表达式的指数。</p><p>之后就是计算了，计算我是在Expression，Term等类中设置了calValue方法，Var的calValue代码如下<br><img src="/pictures/OO_1(20).png" alt="alt text"><br>计算的过程也是递归的过程，可以看到计算的结果就是Standard的Arraylist，这也代表了树的每个节点的价值。</p><h3 id="Calculation"><a href="#Calculation" class="headerlink" title="Calculation"></a>Calculation</h3><p>对于通用的计算，我采用了工厂模式，比如两个Arraylist Standard的相乘，相加，相减(第一次作业没写，后来改的)，计算导数，部分代码如图所示。<br><img src="/pictures/OO_1(21).png" alt="alt text"><br>而其中比较让人头疼的是我们如何去合并，第一次作业比较简单，只需要看指数是否相同，而之后的作业则是需要专门写一个来看是否符合合并的要求，满足exp里面的因子完全相等和x的指数相等才满足合并条件。下图分别是合并和判断是否完全相等。<br><img src="/pictures/OO_1(22).png" alt="alt text"><br><img src="/pictures/OO_1(23).png" alt="alt text"></p><h3 id="Printer"><a href="#Printer" class="headerlink" title="Printer"></a>Printer</h3><p>计算完了之后，我们需要最终打印输出，这部分也是递归调用，我是用StringBuilder来操作的，注意的是第一个如果是+号则去除以及简单的优化比如1*x写为x。</p><h2 id="五、其他优化"><a href="#五、其他优化" class="headerlink" title="五、其他优化"></a>五、其他优化</h2><p>完全没涉及，正确性优先，而且评论区大佬的提取公因式啥的看着也挺麻烦的也不一定能优化。</p><h2 id="四、架构设计"><a href="#四、架构设计" class="headerlink" title="四、架构设计"></a>四、架构设计</h2><h3 id="第一次作业架构"><a href="#第一次作业架构" class="headerlink" title="第一次作业架构"></a>第一次作业架构</h3><p>第一次作业的架构图如下<br><img src="/pictures/OO_1(9).png" alt="alt text"><br>我在第二次作业时经历了重构，相比于第一次作业的架构我提取了Calculation来提供计算方法，以及我提取出了标准项而不是像第一次作业一样简单的用Hashmap来计算，以及我创建了一个Printer类来负责输出。</p><h3 id="第二次与第三次作业架构"><a href="#第二次与第三次作业架构" class="headerlink" title="第二次与第三次作业架构"></a>第二次与第三次作业架构</h3><p>第二次作业经历了重构后我的架构基本定型，第三次作业在第二次的架构上增添完成。</p><h3 id="架构优缺点分析与新情景设想"><a href="#架构优缺点分析与新情景设想" class="headerlink" title="架构优缺点分析与新情景设想"></a>架构优缺点分析与新情景设想</h3><p>我认为我的架构的缺点在于预处理时涉及的情况太多太杂容易疏忽疏漏，特别是在预处理时替换自定义表达式的时候，有很多的情况需要处理，感觉面向过程的思想还存留许多。优点呢是比较能体现面向对象的，各个类的分工是比较明确的。</p><p>对于新的场景的话，如果增加了因子则是接上因子接口然后写他的calValue就行，然后还需要改写Lexer和Parser，扩展性还是比较强的。</p><h2 id="六、度量分析"><a href="#六、度量分析" class="headerlink" title="六、度量分析"></a>六、度量分析</h2><p><img src="/pictures/OO_1(3).png" alt="alt text"><br>我们可以看到Calculation和Lexer和Printer的复杂度比较高，Lexer的复杂度比较高可能是因为在预处理的时候展开自定义函数的过程写的比较复杂导致的，而Calculation的复杂度较高是因为进行了多次遍历来计算导致的，而Printer的复杂度较高是因为多次循环来输出最终结果。</p><h2 id="七、代码规模"><a href="#七、代码规模" class="headerlink" title="七、代码规模"></a>七、代码规模</h2><p><img src="/pictures/OO_1(1).png" alt="alt text"></p><p><img src="/pictures/OO_1(2).png" alt="alt text"></p><h2 id="八、Bug以及Hack策略"><a href="#八、Bug以及Hack策略" class="headerlink" title="八、Bug以及Hack策略"></a>八、Bug以及Hack策略</h2><h3 id="hw1"><a href="#hw1" class="headerlink" title="hw1"></a>hw1</h3><p>hw1中我的Bug是未在预处理的时候处理连续的三个符号，导致了强测寄了3个点都是RE，互测也因为这一点被狠狠地刀了。<br>圈复杂度的话这个出错的方法很高<br><img src="/pictures/OO_1(3).png" alt="alt text"></p><h3 id="hw2"><a href="#hw2" class="headerlink" title="hw2"></a>hw2</h3><p>hw2是bug最多的一次作业，其中最大的一个是统计自定义函数的自变量数量时忘记了去掉空格和制表符导致强测寄了8个点，特别惨痛的教训，一定要认真读题，我应该养成读题的时候记录要点的习惯然后再开始写，还有一个bug是没有用BigInteger存储x的指数，也是读题不充分，思考不充分导致的问题。仔细读题的重要性可见一斑。<br><img src="/pictures/OO_1(4).png" alt="alt text"><br>这张图可以看出这个经常出bug的方法圈复杂度很高</p><h3 id="hw3"><a href="#hw3" class="headerlink" title="hw3"></a>hw3</h3><p>hw3的bug是hw2遗留下来的，在处理自定义函数展开的时候的bug，这个bug还是因为测试不够充分的原因。</p><h3 id="Hack策略和有效性"><a href="#Hack策略和有效性" class="headerlink" title="Hack策略和有效性"></a>Hack策略和有效性</h3><p>第二次作业我未进入互测，第一次作业和第三次作业我采用的互测策略是先构造一个包含了多个可能错的点的数据交上去，如果能刀中人，就把其中的可能错的点单独交上去，也就是说两次刀中基本上就可以确定被刀中的人的bug。两次作业的互测一共刀中了6刀。</p><h2 id="九、心得体会"><a href="#九、心得体会" class="headerlink" title="九、心得体会"></a>九、心得体会</h2><p>OO第一单元作业真是让我挺感慨的，第一次作业当时一直搞不明白怎么去遍历解析出来的树去得到最终的结果，经过朋友的指导后才明白可以用Hashmap去递归计算，第二次作业发现不能用Hashmap之后我想出了提取出了Standard类来表示标准的单项式，并且把混杂在Expression和Term中的加法，减法，乘法提取出来单独作为Calculation类中的方法来供所有类使用，我觉得这是逐渐走向面向对象，让各个类的分工走向明确的做法，但是我觉得在第二次作业中我对于自定义函数的处理还是面向过程的做法，或许把他带到递归下降解析中会好一些，第三次作业比较简单，完成得也挺快，我在第三次作业中弥补了第二次作业中没有合并的缺失。</p><p>从这个单元的完成中，我觉得我的一个很大的转变是我本来是一个完美主义者，我会对我的设计想的很仔细很清楚才会动手，但是hw2给了我一记重击，我明白了想个大概就得动手写了，很多细节在写的过程中才能明白不是空想能够明白的，我觉得在每个单元的第一次作业对于架构的设计中可以画图多花一些时间考虑扩展性，但是对于看起来比较复杂的扩展任务（比如hw2）我应该想个大概的思路就开始动手，不要拘泥于细节，写着就明白了，正所谓“船到桥头自然直”。</p><p>这个单元我留下了许多的遗憾，比如没有怎么去考虑优化，性能分就没拿多少，比如两次互测都是c房（也基本是性能分过低导致的），读题的不仔细导致了强测的遗憾。包括从心态上更多是完成作业后劫后余生的情形，没有很多感受到完成目的成就感，我想我或许可以在以后的单元少想细节多动手，或许会让我能够切换心态，感受OO的乐趣。顶个小目标，第二单元至少进2次a房，在优化上多下功夫，加油！！！</p><h2 id="十、未来方向"><a href="#十、未来方向" class="headerlink" title="十、未来方向"></a>十、未来方向</h2><p>在第一单元中我目前感觉给我有两大困惑，首先是感觉理论课和实践并没有太大的联系，完成作业主要还是参考指导书和往届学长的博客，理论课并没有很大的帮助。第二个是第一单元的任务让人感觉和实际的联系不大（或许是培养我们的面向对象的思想，初步感受一下），千奇百怪的表达式的解析给我的感觉是用处不是很大。以上只是个人对第一单元的感受，或许可以用作课程改变的参考。</p>]]></content>
      
      
      <categories>
          
          <category> Object Oriented </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git学习笔记</title>
      <link href="/2024/07/03/git/"/>
      <url>/2024/07/03/git/</url>
      
        <content type="html"><![CDATA[<h1 id="git学习笔记"><a href="#git学习笔记" class="headerlink" title="git学习笔记"></a>git学习笔记</h1><h2 id="一、基础知识"><a href="#一、基础知识" class="headerlink" title="一、基础知识"></a>一、基础知识</h2><ol><li>git是分布式版本控制，而CVS和SVN是集中式的版本控制</li></ol><h2 id="二、三种状态"><a href="#二、三种状态" class="headerlink" title="二、三种状态"></a>二、三种状态</h2><ol><li>概念解释：工作区就是电脑里面能看到的目录<br><img src="/pictures/git_1.png" alt="alt text"></li></ol><p>版本库就是.git隐藏文件里面包含了暂存区stage，各个分支以及指针HEAD<br><img src="/pictures/git_2.png" alt="alt text"></p><ol><li>一个文件从来没有被在版本信息中为Untracked，改动已经被提交，也就是commit过后没有动就是Unmodified，一个文件已经被修改但是还没有被git add就是Modified，Stage就是指已经被add了但是还没有被commit的文件<br><img src="/pictures/git_3.png" alt="alt text"></li><li>修改了没有add就是Changes not staged for commit而add了还没有commit就是Changes to be committed,Untracked file就是文件从未被添加</li></ol><h2 id="三、git基本操作"><a href="#三、git基本操作" class="headerlink" title="三、git基本操作"></a>三、git基本操作</h2><ol><li>git init作用是初始化目录作为git仓库</li><li>git add提交到了暂存区 . 和 -A参数的区别在于 .不会把删除给提交，而-A会，所以-A更全面</li><li>git commit -m”instruction message”提交到</li><li>git status查看当前文件夹下的状态</li><li>git diff查看修改内容</li><li>git log查看提交日志，可以加上–pretty&#x3D;oneline参数看省流版本</li><li>版本回退使用git reset –hard 版本号</li><li>对于版本回退后不知道原来版本的版本号的，可以使用git reflog命令</li><li>git checkout – 文件名就是交到了暂存区之后还未被commit之前又做了修改，但是我不想要这个修改了，就用了这条指令来回退到add之后的版本</li><li>要撤销暂存区到工作区，可以git reset HEAD 文件名（也就是add了之后commit之前不想要暂存区的东西了）</li><li>git rm可以删除版本库里面的文件</li><li>git fetch可以将远程仓库的更新拉取到本地，但是不合并，git pull &#x3D; git fetch + git merge</li><li>对于大文件，git一般不允许几十MB及以上的提交，可以用git-lfs</li></ol><h2 id="四、远程仓库"><a href="#四、远程仓库" class="headerlink" title="四、远程仓库"></a>四、远程仓库</h2><ol><li>git remote add origin git+网址添加远程仓库</li><li>git push -u origin master推送本地库的所有内容到远程库</li><li>git clone和git pull的区别在于git clone包含了所有的历史提交，而git pull只是最新的提交而且git pull需要先git remote add SSH</li></ol><h2 id="五、分支管理"><a href="#五、分支管理" class="headerlink" title="五、分支管理"></a>五、分支管理</h2><ol><li>HEAD指向的是当前分支，master分支是主分支<br><img src="/pictures/git_4.png" alt="alt text"></li><li>master指向的是提交</li><li>git checkout -b 分支名创建并切换到新分支</li><li>git branch查看分支git branch -d 分支名则是删除这个分支</li><li>switch也可以用于分支相关的操作</li><li>git log也可以查看分支图</li><li>git stash可以暂存工作现场</li><li>cherry-pick命令可以复制一个特定的提交</li><li>git branch -D可以强行删除没有合并的分支</li><li>切换分支之前一定要add并commit，否则会有残留的之前分支的内容</li></ol><h2 id="六、-gitignore文件的编写"><a href="#六、-gitignore文件的编写" class="headerlink" title="六、.gitignore文件的编写"></a>六、.gitignore文件的编写</h2><ol><li>以&#x2F;开头表示从根目录下选</li><li>文件的匹配是基于字符串的而不是正则表达式，所以说比如test则是把所有含有test的都忽略，test.py则是忽略该文件，而test.*则是忽略以test为名的所有类型的文件。</li><li>！可以取消忽略，比如之前忽略了test.py文件可以用！test.py来覆盖</li><li>子文件夹的.gitignore文件会覆盖父文件夹中的.gitignore文件</li><li>git checkout lab</li></ol><h2 id="七、Git协议以及公钥使用"><a href="#七、Git协议以及公钥使用" class="headerlink" title="七、Git协议以及公钥使用"></a>七、Git协议以及公钥使用</h2><ol><li>本地协议（Local），HTTP 协议，SSH（Secure Shell）协议及 Git 协议四种协议</li><li>在默认情况下SSH密钥是存储在~&#x2F;.ssh下可以看是否存在id_dsa(pub)文件，id_dsa.pub是存储公钥的，而id_dsa是存储密钥的，如果没有的话可以<code>ssh-keygen -o</code>来生成公钥和密钥。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/07/03/hello-world/"/>
      <url>/2024/07/03/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
